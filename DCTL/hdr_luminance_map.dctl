#include "ty_color_lib.h"
// #include "ty_draw_lib.h"

#define JUDGE_METHOD_RGB2Y   (0)
#define JUDGE_METHOD_MAX_RGB (1)

#define OVER_RANGE_COLOR_M   (0)
#define OVER_RANGE_COLOR_Y   (1)
#define OVER_RANGE_COLOR_C   (2)

__CONSTANT__ float3 over_range_color_m_3f = {1.0f, 0.3f, 1.0f};
__CONSTANT__ float3 over_range_color_y_3f = {1.0f, 1.0f, 0.4f};
__CONSTANT__ float3 over_range_color_c_3f = {0.7f, 1.0f, 1.0f};

__CONSTANT__ float scale_cv_list[] = {0.5080784, 0.5791332, 0.6218628, 0.6525786, 0.6962941, 0.7518271, 0.8274246, 0.8714864, 0.9025724, 0.9460286, 1.0000000};
__CONSTANT__ int scale_y_list[] = {100, 200, 300, 400, 600, 1000, 2000, 3000, 4000, 6000, 10000};
__CONSTANT__ int scale_cv_list_size = 11;

DEFINE_UI_PARAMS(gamut_idx, Timeline Color Gamut, DCTLUI_COMBO_BOX, 2, { GAMUT_IDX_BT709, GAMUT_IDX_P3D65, GAMUT_IDX_BT2020 }, { Rec.709, P3-D65, Rec.2020 })
DEFINE_UI_PARAMS(judge_data_idx, Judgment Data Type, DCTLUI_COMBO_BOX, 0, { JUDGE_METHOD_RGB2Y, JUDGE_METHOD_MAX_RGB }, { Luminance_RGB2Y, Max_Value_Among_RGB })
DEFINE_UI_PARAMS(over_range_color_idx, Over Range Color, DCTLUI_COMBO_BOX, 0, { OVER_RANGE_COLOR_M, OVER_RANGE_COLOR_Y, OVER_RANGE_COLOR_C }, { Magenta, Yellow, Cyan })
DEFINE_UI_PARAMS(st_luminance, Start [cd/m2], DCTLUI_SLIDER_INT, 100, 100, 500, 1)
DEFINE_UI_PARAMS(ed_luminance, End [cd/m2], DCTLUI_SLIDER_INT, 1000, 500, 10000, 1)
DEFINE_UI_PARAMS(show_scale, Show scale, DCTLUI_CHECK_BOX, 1)

__CONSTANT__ float st_pos_h_rate = 0.01;
__CONSTANT__ float st_pos_v_rate = 0.05;
__CONSTANT__ float ed_pos_h_rate = 0.03;
__CONSTANT__ float ed_pos_v_rate = 0.95;
__CONSTANT__ float scale_h_rate = 0.2;
__CONSTANT__ float font_size_rate = 2;
__CONSTANT__ float pq_100_cv = 0.508078421517;
__CONSTANT__ float pq_10000_cv = 1.0;

float3 lerp_f3(float3 a, float3 b, float t)
{
    return a + t * (b - a);
}

// Apply SDR false color (monochrome gamma correction)
float3 apply_sdr_false_color(float y)
{
    float v = pow(y, 1.0 / 1.1);
    return float3(v, v, v);
}

// Interpolate between two palette entries
float3 interp_palette(float3 a, float3 b, float segmentStart, float segmentEnd, float x)
{
    return lerp(a, b, (x - segmentStart) / (segmentEnd - segmentStart));
}

// Palette functions for each band (x in [0,1])
float3 apply_palette0(float x)
{
    if (x <= 0.2)  return lerp(p0_0, p0_1, x / 0.2);
    if (x <= 0.4)  return lerp(p0_1, p0_2, (x - 0.2) / 0.2);
    if (x <= 0.6)  return lerp(p0_2, p0_3, (x - 0.4) / 0.2);
    if (x <= 0.8)  return lerp(p0_3, p0_4, (x - 0.6) / 0.2);
                   return lerp(p0_4, p0_5, (x - 0.8) / 0.2);
}

float3 apply_palette1(float x)
{
    if (x <= 0.2)  return lerp(p1_0, p1_1, x / 0.2);
    if (x <= 0.4)  return lerp(p1_1, p1_2, (x - 0.2) / 0.2);
    if (x <= 0.6)  return lerp(p1_2, p1_3, (x - 0.4) / 0.2);
    if (x <= 0.8)  return lerp(p1_3, p1_4, (x - 0.6) / 0.2);
                   return lerp(p1_4, p1_5, (x - 0.8) / 0.2);
}

float3 apply_palette2(float x)
{
    if (x <= 0.2)  return lerp(p2_0, p2_1, x / 0.2);
    if (x <= 0.4)  return lerp(p2_1, p2_2, (x - 0.2) / 0.2);
    if (x <= 0.6)  return lerp(p2_2, p2_3, (x - 0.4) / 0.2);
    if (x <= 0.8)  return lerp(p2_3, p2_4, (x - 0.6) / 0.2);
                   return lerp(p2_4, p2_5, (x - 0.8) / 0.2);
}

float3 apply_palette3(float x)
{
    if (x <= 0.2)  return lerp(p3_0, p3_1, x / 0.2);
    if (x <= 0.4)  return lerp(p3_1, p3_2, (x - 0.2) / 0.2);
    if (x <= 0.6)  return lerp(p3_2, p3_3, (x - 0.4) / 0.2);
    if (x <= 0.8)  return lerp(p3_3, p3_4, (x - 0.6) / 0.2);
                   return lerp(p3_4, p3_5, (x - 0.8) / 0.2);
}

float3 apply_palette4(float x)
{
    if (x <= 0.2)  return lerp(p4_0, p4_1, x / 0.2);
    if (x <= 0.4)  return lerp(p4_1, p4_2, (x - 0.2) / 0.2);
    if (x <= 0.6)  return lerp(p4_2, p4_3, (x - 0.4) / 0.2);
    if (x <= 0.8)  return lerp(p4_3, p4_4, (x - 0.6) / 0.2);
                   return lerp(p4_4, p4_5, (x - 0.8) / 0.2);
}

float3 apply_palette5(float x)
{
    if (x <= 0.2)  return lerp(p5_0, p5_1, x / 0.2);
    if (x <= 0.4)  return lerp(p5_1, p5_2, (x - 0.2) / 0.2);
    if (x <= 0.6)  return lerp(p5_2, p5_3, (x - 0.4) / 0.2);
    if (x <= 0.8)  return lerp(p5_3, p5_4, (x - 0.6) / 0.2);
                   return lerp(p5_4, p5_5, (x - 0.8) / 0.2);
}

float3 apply_palette6(float x)
{
    if (x <= 0.2)  return lerp(p6_0, p6_1, x / 0.2);
    if (x <= 0.4)  return lerp(p6_1, p6_2, (x - 0.2) / 0.2);
    if (x <= 0.6)  return lerp(p6_2, p6_3, (x - 0.4) / 0.2);
    if (x <= 0.8)  return lerp(p6_3, p6_4, (x - 0.6) / 0.2);
                   return lerp(p6_4, p6_5, (x - 0.8) / 0.2);
}

// Main false color function for luminance Y
float3 apply_false_color(float y)
{
    if (y <= t1) {
        // SDR region: monochrome mapping
        return apply_sdr_false_color(y);
    }
    else if (y <= t2) {
        float x = (y - t1) / (t2 - t1);
        return apply_palette0(x);
    }
    else if (y <= t3) {
        float x = (y - t2) / (t3 - t2);
        return apply_palette1(x);
    }
    else if (y <= t4) {
        float x = (y - t3) / (t4 - t3);
        return apply_palette2(x);
    }
    else if (y <= t5) {
        float x = (y - t4) / (t5 - t4);
        return apply_palette3(x);
    }
    else if (y <= t6) {
        float x = (y - t5) / (t6 - t5);
        return apply_palette4(x);
    }
    else if (y <= t7) {
        float x = (y - t6) / (t7 - t6);
        return apply_palette5(x);
    }
    else if (y <= t8) {
        float x = (y - t7) / (t8 - t7);
        return apply_palette6(x);
    }

    // Above the highest threshold: use final palette color
    return p6_5;
}

// main function
__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
    float3 rgb_in = to_float3(p_R, p_G, p_B);
    float3 rgb_linear = eotf_st2084_f3(rgb_in);

    // convert to Y
    float y;
    if(judge_data_idx == JUDGE_METHOD_RGB2Y){
        y = rgb_2_y(rgb_linear, gamut_idx);
    }
    else if(judge_data_idx == JUDGE_METHOD_MAX_RGB){
        y = _fmaxf(_fmaxf(rgb_linear.x, rgb_linear.y), rgb_linear.z);
    }
    else{
        y = rgb_2_y(rgb_linear, gamut_idx);
    }

    float3 false_color_linear = apply_false_color(y);

    float3 out = oetf_st2084_f3(false_color_linear);

    return out;
}
